{
  "name": "Ayudantia binario",
  "tagline": "",
  "body": "# Ayudantia binario\r\nPor [Francisco Olivares](https://github.com/fco96)\r\n\r\n## Explicación\r\n\r\nPara el manejo de archivos (en binario) C nos provee de 2 funciones *fread* y *fwrite*, las cuales están organizadas de la siguiente manera:\r\n\r\n```C\r\nfread(d,t,n,fp);\r\n```\r\n\r\nDonde ``d`` es el la dirección del destino donde se desea guardar lo que se lea, ``t`` es el tamaño de cada elemento (en bits) que se está leyendo, ``n`` es el número de elementos que se leen y ``fp`` es un puntero al archivo desde el cual se lee.\r\n\r\n```C\r\nfwrite(d,t,n,fp);\r\n```\r\n\r\nDonde ``d`` es el la dirección de la variable(s) a escribir, ``t`` es el tamaño de cada elemento (en bits) que se va a escribir, ``n`` es el número de elementos que se escriben y ``fp`` es un puntero al archivo en donde se escribirá.\r\n\r\n## Ejemplos\r\n### Ejemplo 1\r\nDigamos que se quiere escribir una variable de tipo ``int`` llamado contador en un archivo (salida.txt) entonces se tendría que escribir algo similar lo siguiente\r\n\r\n```C\r\nint contador=9999;\r\nFILE *fp=fopen(\"salida.txt\",\"w\");\r\nfwrite(&contador,sizeof(int),1,fp);\r\nfclose(fp);\r\n```\r\nNotar que el parámetro ``d`` es una direccion de memoria entonces por eso entra ``&contador``, se asume que el archivo salida.txt no estaba creado por eso se le da la opción ``\"w\"``.\r\n\r\n### Ejemplo 2\r\nDigamos que se quiere leer una variable desde un archivo (input.txt) de tipo ``float`` y almacenarla entonces el codigo sería\r\n\r\n```C\r\nfloat constante;\r\nFILE *fp=fopen(\"input.txt\",\"r\");\r\nfread(&constante,sizeof(float),1,fp);\r\nfclose(fp);\r\n```\r\n### Ejemplo 3 (Caso General de escritura)\r\nSe desea generar un programa el cual escriba en memoria un arreglo de 10 espacios de tipo de dato libro.\r\n\r\n```C\r\ntypedef struct a{\r\nchar *autor,*editorial;\r\nint numero_paginas, anio_emision;  \r\n}libro;\r\nlibro arreglo[10]; // tambien podria ser *puntero\r\nFILE *fp=fopen(\"salida.txt\",\"w\");\r\nfwrite(arreglo,sizeof(libro),10,fp); // en vez de arreglo ponen puntero\r\nfclose(fp);\r\n```\r\nNotar que ``d`` recibe una dirección de memoria desde donde se va a empezar a escribir y el nombre de __un arreglo es un puntero implícito a la base de este__ entonces por eso va ``arreglo`` y __no__ ``&arreglo.``. Existe la posibilidad de ocupar ``puntero`` en ves de ``arreglo[10]`` siempre y cuando el ``puntero`` apunte a un arreglo de 10 libros.\r\n### Ejemplo 4 (Caso General de lectura)\r\nSe desea escribir un programa que cargue desde un archivo una arreglo de libros a una variable, da la casualidad que usted sabe que dicho arreglo es de 10 espacios ;)\r\n```C\r\ntypedef struct a{\r\nchar *autor,*editorial;\r\nint numero_paginas, anio_emision;  \r\n}libro;\r\nlibro arreglo_a_cargar[10]; // tambien podria ser *puntero\r\nFILE *fp=fopen(\"input.txt\",\"r\");\r\nfread(arreglo_a_cargar,sizeof(libro),10,fp); // en vez de arreglo_a_cargar ponen puntero\r\nfclose(fp);\r\n```\r\nSe puede poner ``puntero`` como parámetro de la funcion *fread* siempre y cuando ``puntero`` apunte a un arreglo con 10 espacios para libros.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}